#! /usr/bin/env bash

declare possible_vname=
read possible_vname <<< "$(echo $* | sed -r 's/.*:([^[:space:]]+)$/\1/')"

declare sed_pattern= sed_substitution= sed_result=


sed_pattern='^([^[:space:]]+)(.*)'
sed_substitution='\1:\2'


# if vname still match list of passed argument then retrival failed
if [[ "$*" != "$possible_vname" ]]
then
	sed_pattern+="[[:space:]]:"$possible_vname"\$"
	declare vname="${possible_vname}"
fi


sed_result=$(echo "$*" | sed -r  "s/${sed_pattern}/${sed_substitution}/")

declare IFS=':'
read cmd_name options <<< $sed_result
declare IFS=



if [[ -z $cmd_name ]]
then
	echo "Missing following arguments: Sub-Command"
	exit 1
fi

# resolve [--] short hand
if [[ "$cmd_name" == "--" ]]
then
	cmd_name="raw"
	options="-q -- ${options} ${vname}"
else
	# export vname
	declare -x vname
fi

# convert options into array
declare -a options="(${options})"


# form subcommand exec pathname
resolved_path="${sub_cmd_pathname}/${cmd_name}"
dot_exec="${resolved_path}/.exec"

# throw error if no exec file is found
if [[ ! -f $dot_exec ]]
then
	echo "Sub-command exec file not found at: \"${dot_exec}\""
fi

# parse options if provided
if [[ ${#options} -gt 0 ]]
then
	options_parser ${options[@]}
fi

# export sub_command_path
declare -x cwd=$resolved_path

# execute subcommand
bash $dot_exec

