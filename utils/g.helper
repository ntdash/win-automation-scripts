#! /usr/bin/env bash

# check if value is defined
is_defined()
{
	declare -p $1 2>&1 /dev/null

	return $?
}

# check if value is array
is_array()
{
	declare patttern="^declare -[aA]"

	[[ "$(declare -p ${1} 2>/dev/null)" =~ $patttern ]]

	return $?
}

# check if variable is associative array
is_assoc_array()
{
	declare patttern="^declare -A"

	[[ "$(declare -p ${1} 2>/dev/null)" =~ $patttern ]]

	return $?
}

# if $2!=undefined, assign bound value to rvalue and return appropriate error_code
# @param[1] :option_name = string
# @param[2] :expect_value = true|input|undefined
# @return int
	#> ?0 found
	#> ?1 not found
	#> ?2 value not found

options_manager()
{
	# load parsed_options
	source $parsed_options

	# throw error if collection not defined
	[[ $( is_assoc_array collection ) ]] && echo "Failed to retrieve parsed option's collection." && return 1

	# declare local returners
	declare -i rcode=0
	declare rvalue=

	case $1 in

		"get")
			case $2 in

				"keys")
					rvalue=${!collection[@]}
				;;

				# error_message="Failed to retrieve value of option:\"${3}\"."
				"value")
					rvalue=${collection[$3]}

					[[ -z $rvalue ]] && rcode=2
				;;

				# error_message="Failed to retrieve \"${2}\"."
				*)
					rcode=1
				;;
			esac
		;;

		"check")

			[[ " ${!collection[@]} " =~ $3 ]] && rcode=0 || rcode=1
		;;

		# echo "Failed to proccess \"${1}\""
		*)
			rcode=1
		;;
	esac


	# early return if inline usage of returned value
	[[ $rcode -eq 0 ]] && echo $rvalue

	return $rcode
}


option_value()
{

	# prepare bind value with ref if given
	[[ -n $2 ]] && [[ "$2" =~ ^:.+ ]] && declare xval="${2:1}" && declare -g $xval && declare -n rval=$xval

	# encapsulation
	declare cval=

	cval=$(options_manager get value $1)


	[[ $? -ne 0 ]] && echo "Failed to retrieve value of option \"${1}\"." && return 1

	[[ $(is_defined rval ) ]] && rval=$cval || echo $cval

	return $?
}

option_key_exists()
{
	options_manager check $1 2>&1 /dev/null

	return $?
}

option_keys()
{
	# prepare bind value with ref if given
	[[ -n $1 ]] && [[ "$1" =~ ^:.+ ]] && declare xval="${1:1}" && declare -ag $xval && declare -n rval=$xval

	declare -a cval=

	cval=$(options_manager get keys)

	[[ $(is_defined rval ) ]] && rval=(${cval[@]}) || echo $cval

	return $?
}

options_parser()
{
	declare -A collection

	# check options format
	[[ ! "${1}" =~ ^-(-?)(.+) ]] && echo "Given options \"${@}\" does not satisfy the expected format" && return 1;

	# vars
	declare ckey= entry= collector=

	while read entry
	do
		# shift the retrieved params
		shift;

		[[ -z $entry ]] && continue

		[[ "${entry}" == "--" ]] && [[ -n $ckey ]] && collector=true && break

		# check if current entry is a key
		if [[ "${entry}" =~ ^-(-?)(.+) ]]
		then

			# check if current key is a shorthand
			if [[ -z ${BASH_REMATCH[1]} ]]
			then

				declare list=`echo ${BASH_REMATCH[2]} | grep -o .`

				if [[ ${#list[@]} -gt 1 ]]
				then
					# loop current value
					declare k

					for k in ${list[@]}
					do
						# init
						collection[$k]=
					done

					# keep last value
					ckey="${k}"

					# skip
					continue;

				else
					# sole shorthand
					ckey="${list[0]}"
				fi

			else
				# long hand
				ckey="${BASH_REMATCH[2]}"
			fi

			# init
			collection[$ckey]=

			# skip
			continue;

		fi

		# add value to last registered key
		collection[$ckey]+=" ${entry} "

	done <<< "$(echo $@ | sed 's/\s/\n/g')"

	[[ "$collector" == "true" ]] && [[ $# -gt 0 ]] && collection[$ckey]+=" ${@} " || collector=

	[[ $? -ne 0 ]] && echo "Failed to parse given options: \"${@}\"" && return 1

	# dump collection into tmp file
	declare -p collection > $parsed_options
}

# option helpers
declare -xf options_parser
declare -xf options_manager
declare -xf option_value
declare -xf option_keys
declare -xf option_key_exists
# definition helpers
declare -xf is_defined
declare -xf is_array
declare -xf is_assoc_array
