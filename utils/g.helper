#! /usr/bin/env bash

# extract sub command for stdin
# @params string[]
# @rvalue [$cmd, ?$options]
# @throw error_code 1
strip_subcommand()
{
	# global returner
	rvalue=

	# local assignment
	local cmd=
	local options=

	# conds
	[[ -n $1 ]] && cmd=$1 || return 1

	[[ -n $2 ]] && options=${@:2}

	# return
	rvalue=("${cmd}" "${options}")
}

# check if value is defined
is_defined()
{
	declare -p $1 |& /dev/null

	return $?
}


# check if value is array
is_array()
{
	declare patttern="^declare -[aA]"

	[[ "$(declare -p ${1} 2>/dev/null)" =~ $patttern ]]

	return $?
}

# check if variable is associative array
is_assoc_array()
{
	declare patttern="^declare -A"

	[[ "$(declare -p ${1} 2>/dev/null)" =~ $patttern ]]

	return $?
}

# if $2!=undefined, assign bound value to rvalue and return appropriate error_code
# @param[1] :option_name = string
# @param[2] :expect_value = true|input|undefined
# @return int
	#> ?0 found
	#> ?1 not found
	#> ?2 value not found
get_option()
{
	# global returner
	declare -g rvalue


	# load parsed_options
	source $parsed_options

	# throw error if collection not defined
	[[ $( is_assoc_array collection ) -ne 0 ]] && echo "Parsed options not found" && return 1

	# check if key exist
	if [[ " ${!collection[@]} " =~ $1 ]]
	then

		rvalue=${collection[$1]}

		if [[ "${2}" =~ (true|input) ]]
		then

			# return error_code=2 if value is expected but not found
			[[ -z $rvalue ]] && return 2

			[[ "${2}" == "input" ]] && echo $rvalue

		fi

		return 0
	fi

	return 1
}


options_parser()
{
	declare -A collection
	# current key
	declare ckey

	# check options format
	[[ ! "${1}" =~ ^-(-?)(.+) ]] && echo "Given options \"${@}\" does not satisfy the expected format" && return 1;

	for _entry in $@
	do

		# check if current _entry is a key
		if [[ "${_entry}" =~ ^-(-?)(.+) ]]
		then

			# check if current key is a shorthand
			if [[ -z ${BASH_REMATCH[1]} ]]
			then

				declare list=`echo ${BASH_REMATCH[2]} | grep -o .`

				if [[ ${#list[@]} -gt 1 ]]
				then
					# loop current value
					declare k

					for k in ${list[@]}
					do
						# init
						collection[$k]=
					done

					# keep last value
					ckey="${k}"

					# skip
					continue;

				else
					# sole shorthand
					ckey="${list[0]}"
				fi

			else
				# long hand
				ckey="${BASH_REMATCH[2]}"
			fi

			# init
			collection[$ckey]=

			# skip
			continue;

		fi

		# add value to last registered key
		collection[$ckey]+=" ${_entry} "

	done

	[[ $? -ne 0 ]] && echo "Failed to parse given options: \"${@}\"" && return 1

	# dump collection into tmp file
	declare -p collection > $parsed_options
}

declare -xf strip_subcommand
declare -xf options_parser
declare -xf get_option


# utils
declare -xf is_defined
declare -xf is_array
declare -xf is_assoc_array
